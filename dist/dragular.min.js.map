{"version":3,"sources":["dragular.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","dragularModule","directive","dragularService","restrict","link","$scope","iElm","iAttrs","tryJson","json","JSON","parse","options","$eval","dragular","dragularModel","angular","extend","containersModel","./dragularModule","2","dragularDirective","./dragularDirective.js","./dragularService.js","3","factory","$rootScope","regEvent","el","op","type","fn","touch","mouseup","mousedown","mousemove","$el","element","never","always","getRectWidth","rect","width","right","left","getRectHeight","height","bottom","top","emptyObj","nextEl","manually","sibling","nextSibling","nodeType","nextElementSibling","isElement","HTMLElement","nodeName","lookupClass","className","cached","shared","classesCache","lastIndex","RegExp","addClass","current","test","rmClass","replace","trim","getEventHost","targetTouches","changedTouches","getCoord","coord","host","missMap","pageX","pageY","indexOf","originalEvent","touches","domIndexOf","child","parent","Array","prototype","children","fireEvent","target","extra","dispatchEvent","eventType","containersCtx","containers","mirror","source","item","copy","sourceItem","sourceModel","targetCtx","targetModel","lastDropTarget","offsetX","offsetY","offsetXr","offsetYb","clientX","clientY","mirrorWidth","mirrorHeight","initialSibling","currentSibling","initialIndex","currentIndex","isContainerModel","dragOverEvents","lastElementBehindCursor","grabbed","serviceFn","initialContainers","makeArray","all","startIndex","isArray","slice","removeContainers","applyAsync","changes","forEach","container","nameSpace","index","splice","events","remove","documentElement","release","grab","eventualMovements","startBecauseMouseMoved","movements","preventGrabbed","destroy","preventDefault","window","event","shouldReturn","classList","ignoreClasses","key","hasOwnProperty","push","tagName","ignoreTags","toLowerCase","attributes","ignoreAttributeValues","attributeList","attributeValues","key2","attribute","nodeValue","attributeValue","which","metaKey","ctrlKey","context","canStart","focus","end","start","direction","parentElement","parentHeight","offsetHeight","parentWidth","offsetWidth","childHeight","clientHeight","childWidth","clientWidth","offset","getOffset","boundingBox","classes","transit","renderMirrorImage","style","drag","drake","dragging","handle","isContainer","invalid","moves","manualStart","document","addEventListener","x","y","isCopy","cloneNode","scope","$emit","containerIndex","invalidTarget","drop","ungrab","elementBehindCursor","getElementBehindPoint","dropTarget","findDropTarget","removeOnSpill","cancel","emitDropEvent","isInitialPlacement","dropElm","dropIndex","$applyAsync","dropElmModel","m","removeChild","cleanup","revert","reverts","arguments","revertOnSpill","initial","insertBefore","removeMirrorImage","spillOut","accepted","accepts","immediate","getImmediateChild","reference","getReference","canBeAccepted","moved","spillOver","over","changed","out","offsetBox","lockY","lockX","hide","scrollContainer","before","scrollTop","deltaY","stopPropagation","getBoundingClientRect","mirrorContainer","appendChild","body","unselectable","outside","len","horizontal","inside","resolve","after","getScroll","scrollProp","offsetProp","scrollLeft","point","p","state","elementFromPoint","querySelectorAll","defaultClasses","dragOverEventNames","shLen","dragOverEvent","createEvent","initEvent","createEventObject","cleanEnviroment","undefined"],"mappings":"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","file":"dragular.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Directive by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n var dragularModule = require('./dragularModule');\n\n/**\n* @ngInject\n*/\n\ndragularModule.directive('dragular', ['dragularService', function(dragularService) {\n  return {\n    restrict: 'A',\n    link: function($scope, iElm, iAttrs) {\n\n      var options = $scope.$eval(iAttrs.dragular) || tryJson(iAttrs.dragular) || {};\n\n      function tryJson(json) {\n        try { // I dont like try catch solutions but I havent find sattisfying way of chcecking json validity.\n          return JSON.parse(json);\n        } catch (e) {\n          return undefined;\n        }\n      }\n\n      if(iAttrs.dragularModel){\n        options = angular.extend({containersModel: $scope.$eval(iAttrs.dragularModel)}, options);\n      }else if(options && options.containersModel && typeof options.containersModel === 'string'){\n        options.containersModel = $scope.$eval(options.containersModel);\n      }\n\n      dragularService(iElm[0], options);\n    }\n  };\n}]);\n\n},{\"./dragularModule\":2}],2:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n\n\n/**\n * Dragular 3.0.2 by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\nmodule.exports = angular.module('dragularModule', []);\n\n({\"dragularDirective\":require(\"./dragularDirective.js\"),\"dragularService\":require(\"./dragularService.js\")});\n\n},{\"./dragularDirective.js\":1,\"./dragularService.js\":3}],3:[function(require,module,exports){\n/* global angular */\n'use strict';\n\n/**\n * dragular Service by Luckylooke https://github.com/luckylooke/dragular\n * Angular version of dragula https://github.com/bevacqua/dragula\n */\n\nvar dragularModule = require('./dragularModule');\n\n/**\n * @ngInject\n */\n\ndragularModule.factory('dragularService', ['$rootScope', function dragula($rootScope) {\n\n  var shared = { // function returned as service\n      classesCache: {}, // classes lookup cache\n      containersCtx: {}, // containers model\n      containers: {}, // containers managed by the drake\n      mirror: null, // mirror image\n      source: null, // source container\n      item: null, // item being dragged\n      copy: null, // isCopy flag\n      sourceItem: null, // item originaly dragged if copy is enabled\n      sourceModel: null, // source container model\n      target: null, // droppable container under drag item\n      targetCtx: null, // target container context\n      targetModel: null, // target container model\n      lastDropTarget: null, // last container item was over\n      offsetX: null, // reference x\n      offsetY: null, // reference y\n      offsetXr: null, // reference x right for boundingBox feature\n      offsetYb: null, // reference y bottom for boundingBox feature\n      clientX: null, // cache client x, init at grab, update at drag\n      clientY: null, // cache client y, init at grab, update at drag\n      mirrorWidth: null, // mirror width for boundingBox feature\n      mirrorHeight: null, // mirror height for boundingBox feature\n      initialSibling: null, // reference sibling when grabbed\n      currentSibling: null, // reference sibling now\n      initialIndex: null, // reference model index when grabbed\n      currentIndex: null, // reference model index now\n      isContainerModel: null, // if o.isContainer is used, model can be provided as well, here it is kept\n      dragOverEvents: {}, // drag over events fired on element behind cursor\n      lastElementBehindCursor: null, // last element behind cursor\n      grabbed: null // holds mousedown context until first mousemove\n    },\n    serviceFn = function(initialContainers, options) {\n\n      if (arguments.length === 1 && !Array.isArray(initialContainers) && !angular.isElement(initialContainers) && !initialContainers[0] && typeof initialContainers !== 'string') {\n        // then containers are not provided, only options\n        options = initialContainers;\n        initialContainers = [];\n      } else if (typeof initialContainers === 'string') {\n        initialContainers = document.querySelectorAll(initialContainers);\n      }\n\n      var body = document.body,\n        documentElement = document.documentElement,\n        defaultClasses = {\n          mirror: 'gu-mirror',\n          hide: 'gu-hide',\n          unselectable: 'gu-unselectable',\n          transit: 'gu-transit'\n        },\n        isContainer, // internal isContainer\n        o = { // options\n          dragOverEventNames: ['dragularenter', 'dragularleave', 'dragularrelease'],\n          classes: defaultClasses,\n          containers: false,\n          moves: always,\n          accepts: always,\n          canBeAccepted: always,\n          isContainer: never,\n          copy: false,\n          invalid: invalidTarget,\n          revertOnSpill: false,\n          removeOnSpill: false,\n          lockX: false,\n          lockY: false,\n          boundingBox: false,\n          containersModel: false,\n          isContainerModel: emptyObj\n        };\n\n      if (!isElement(o.boundingBox)) {\n        o.boundingBox = null;\n      }\n\n      if (options && options.classes) {\n        angular.extend(defaultClasses, options.classes);\n        angular.extend(options.classes, defaultClasses);\n      }\n\n      angular.extend(o, options);\n\n      if (!o.mirrorContainer) {\n        o.mirrorContainer = document.body;\n      }\n\n      // get initial containers from options or parameter or fall back to empty array (containers can be also added later)\n      initialContainers = o.containers || initialContainers || [];\n      initialContainers = makeArray(initialContainers);\n\n      if (o.containersModel) {\n        //                            is 2D array?\n        o.containersModel = Array.isArray(o.containersModel[0]) ? o.containersModel : [o.containersModel];\n      } else {\n        o.containersModel = [];\n      }\n\n      // feed containers groups and optionaly shadow it by models\n      if (!o.nameSpace) {\n        o.nameSpace = ['dragularCommon'];\n      }\n      if (!Array.isArray(o.nameSpace)) {\n        o.nameSpace = [o.nameSpace];\n      }\n      o.nameSpace.forEach(function eachNameSpace(nameSpace) {\n        if (!shared.containers[nameSpace]) {\n          shared.containers[nameSpace] = [];\n          shared.containersCtx[nameSpace] = [];\n        }\n        var len = initialContainers.length,\n          shLen = shared.containers[nameSpace].length;\n        for (var i = 0; i < len; i++) {\n          shared.containers[nameSpace][i + shLen] = initialContainers[i];\n          shared.containersCtx[nameSpace][i + shLen] = {\n            o: o,\n            m: o.containersModel[i] // can be undefined\n          };\n        }\n      });\n\n      //register events\n      events();\n\n      angular.forEach(o.dragOverEventNames, function prepareDragOverEvents(dragOverEvent) {\n        if (document.createEvent) {\n          shared.dragOverEvents[dragOverEvent] = document.createEvent('HTMLEvents');\n          shared.dragOverEvents[dragOverEvent].initEvent(dragOverEvent, true, true);\n        } else {\n          shared.dragOverEvents[dragOverEvent] = document.createEventObject();\n          shared.dragOverEvents[dragOverEvent].eventType = dragOverEvent;\n        }\n      });\n\n      isContainer = function isContainer(el) {\n        var i = o.nameSpace.length;\n        while (i--) {\n          if (shared.containers[o.nameSpace[i]].indexOf(el) !== -1) {\n            return true;\n          }\n        }\n        if (o.isContainer(el)) {\n          shared.isContainerModel = o.isContainerModel(el);\n          return true;\n        } else {\n          shared.isContainerModel = null;\n        }\n        return false;\n      };\n\n      var drake = {\n        containers: shared.containers,\n        containersCtx: shared.containersCtx,\n        isContainer: isContainer,\n        start: manualStart,\n        end: end,\n        cancel: cancel,\n        remove: remove,\n        destroy: destroy,\n        dragging: false\n      };\n\n      return drake;\n\n      // make array from array-like objects or from single element (based on bevacqua/atoa)\n      function makeArray(all, startIndex) {\n        if (Array.isArray(all)) {\n          return all;\n        }\n        if (all.length) { // is array-like\n          return Array.prototype.slice.call(all, startIndex);\n        } else { // is one element\n          return [all];\n        }\n      }\n\n      // add or remove containers - deprecated\n      function removeContainers(all) {\n        $rootScope.applyAsync(function applyDestroyed() {\n          var changes = Array.isArray(all) ? all : makeArray(all);\n          changes.forEach(function forEachContainer(container) {\n            angular.forEach(o.nameSpace, function forEachNs(nameSpace) {\n              var index;\n              index = shared.containers[nameSpace].indexOf(container);\n              shared.containers[nameSpace].splice(index, 1);\n              shared.containersCtx[nameSpace].splice(index, 1);\n            });\n          });\n        });\n      }\n\n      function events(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(documentElement, op, 'mouseup', release);\n\n        initialContainers.forEach(function addMouseDown(container) {\n          regEvent(container, 'on', 'mousedown', grab);\n        });\n      }\n\n      function eventualMovements(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(documentElement, op, 'mousemove', startBecauseMouseMoved);\n      }\n\n      function movements(remove) {\n        var op = remove ? 'off' : 'on';\n        regEvent(documentElement, op, 'selectstart', preventGrabbed); // IE8\n        regEvent(documentElement, op, 'click', preventGrabbed);\n        regEvent(documentElement, op, 'touchmove', preventGrabbed); // fixes touch devices scrolling while drag\n      }\n\n      function destroy() {\n        events(true);\n        removeContainers(initialContainers);\n        release({});\n      }\n\n      function preventGrabbed(e) {\n        if (shared.grabbed) {\n          e.preventDefault();\n        }\n      }\n\n      function grab(e) {\n        e = e || window.event;\n        // Add logic to ignore elements by tagName, classes, and attribute values if passed in options\n        var shouldReturn = false;\n        if (e.target) {\n          if (e.target.classList && e.target.classList && o.ignoreClasses) {\n            var classList = [];\n            for (var key in e.target.classList) {\n              if (e.target.classList.hasOwnProperty(key)) {\n                classList.push(e.target.classList[key]);\n              }\n            }\n            o.ignoreClasses.forEach(function(className) {\n              if (classList.indexOf(className) !== -1) {\n                shouldReturn = true;\n              }\n            });\n          }\n          if (e.target.tagName && o.ignoreTags) {\n            o.ignoreTags.forEach(function(tagName) {\n              if (e.target.tagName.toLowerCase() === tagName) {\n                shouldReturn = true;\n              }\n            });\n          }\n          if (e.target.attributes && o.ignoreAttributeValues) {\n            var attributeList = [];\n            var attributeValues = [];\n            for (var key2 in e.target.attributes) {\n              if (e.target.attributes.hasOwnProperty(key2)) {\n                attributeList.push(e.target.attributes[key2]);\n              }\n            }\n            attributeList.forEach(function(attribute) {\n              attributeValues.push(attribute.nodeValue);\n            });\n            o.ignoreAttributeValues.forEach(function(attributeValue) {\n              if (attributeValues.indexOf(attributeValue) !== -1) {\n                shouldReturn = true;\n              }\n            });\n          }\n        }\n        if (shouldReturn) {\n          return;\n        }\n        // filter some odd situations\n        if ((e.which !== 0 && e.which !== 1) || e.metaKey || e.ctrlKey) {\n          return; // we only care about honest-to-god left clicks and touch events\n        }\n\n        var context = canStart(e.target);\n        if (!context) {\n          return;\n        }\n\n        shared.grabbed = context;\n        eventualMovements();\n        if (e.type === 'mousedown') {\n          e.preventDefault(); // fixes https://github.com/bevacqua/dragula/issues/155\n          if (context.item.tagName === 'INPUT' || context.item.tagName === 'TEXTAREA') {\n            context.item.focus(); // fixes https://github.com/bevacqua/dragula/issues/176\n          }\n        }\n      }\n\n      function startBecauseMouseMoved(e) {\n        var grabbed = shared.grabbed; // call to end() unsets _grabbed\n        eventualMovements(true); // remove mousemove listener\n        movements();\n        end();\n        start(grabbed);\n\n        // automaticly detect direction of elements if not set in options\n        if (!o.direction) {\n          var parent = shared.sourceItem.parentElement,\n            parentHeight = parent.offsetHeight,\n            parentWidth = parent.offsetWidth,\n            childHeight = shared.sourceItem.clientHeight,\n            childWidth = shared.sourceItem.clientWidth;\n          o.direction = parentHeight / childHeight < parentWidth / childWidth ? 'horizontal' : 'vertical';\n        }\n\n        // get initial coordinates, used to render shared.mirror for first time\n        var offset = getOffset(shared.sourceItem);\n        shared.offsetX = getCoord('pageX', e) - offset.left;\n        shared.offsetY = getCoord('pageY', e) - offset.top;\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        // limiting area of shared.mirror movement, get initial coordinates\n        if (o.boundingBox) {\n          shared.offsetXr = getCoord('pageX', e) - offset.right;\n          shared.offsetYb = getCoord('pageY', e) - offset.bottom;\n        }\n\n        e.preventDefault();\n\n        addClass(shared.item, o.classes.transit);\n        renderMirrorImage();\n        // initial position\n        shared.mirror.style.left = shared.clientX - shared.offsetX + 'px';\n        shared.mirror.style.top = shared.clientY - shared.offsetY + 'px';\n\n        drag(e);\n      }\n\n\n      function canStart(item) {\n        if (drake.dragging && shared.mirror) {\n          return; // already dragging\n        }\n\n        var handle = item;\n\n        while (item.parentElement &&\n          !isContainer(item.parentElement)) {\n          // break loop if user tries to drag item which is considered invalid handle\n          if (o.invalid(item, handle)) {\n            return;\n          }\n          item = item.parentElement; // drag target should be immediate child of container\n          if (!item) {\n            return;\n          }\n        }\n\n        var source = item.parentElement;\n        if (!source ||\n          o.invalid(item, handle) ||\n          !o.moves(item, source, handle)) {\n          return;\n        }\n\n        return {\n          item: item,\n          source: source\n        };\n      }\n\n      function manualStart(item) {\n        var context = canStart(item);\n        if (context) {\n          start(context);\n        }\n      }\n\n      function start(context) {\n        shared.sourceItem = shared.item = context.item;\n        shared.source = context.source;\n        shared.initialSibling = shared.currentSibling = nextEl(context.item);\n\n        // Keep last x and y coordinates for touch events\n        document.addEventListener('touchmove', function(event) {\n          shared.touch = shared.touch || {};\n          shared.touch.x = event.touches[0]['pageX'];\n          shared.touch.y = event.touches[0]['pageY'];\n        });\n\n        if (isCopy(context.item, context.source)) {\n          shared.item = context.item.cloneNode(true);\n          shared.copy = true;\n          if (o.scope) {\n            o.scope.$emit('dragularcloned', shared.item, context.item);\n          }\n        } else {\n          shared.copy = false;\n        }\n\n        // prepare models operations\n        var containerIndex = initialContainers.indexOf(context.source);\n        shared.sourceModel = o.containersModel[containerIndex];\n        shared.initialIndex = domIndexOf(context.item, context.source);\n\n        drake.dragging = true;\n        if (o.scope) {\n          o.scope.$emit('dragulardrag', shared.sourceItem, shared.source);\n        }\n\n        return true;\n      }\n\n      function invalidTarget() {\n        return false;\n      }\n\n      function end() {\n        if (!drake.dragging) {\n          return;\n        }\n        drop(shared.item, shared.item.parentElement);\n      }\n\n      function ungrab() {\n        shared.grabbed = false;\n        eventualMovements(true);\n        movements(true);\n      }\n\n      function release(e) {\n        ungrab();\n        if (!drake.dragging) {\n          return;\n        }\n        e = e || window.event;\n\n        // Touch accomodations\n        if (e.type.indexOf('touch') < 0) {\n          shared.clientX = getCoord('clientX', e);\n          shared.clientY = getCoord('clientY', e);\n        } else {\n          shared.clientX = shared.touch.x;\n          shared.clientY = shared.touch.y;\n        }\n\n        var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n          dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY);\n\n        if (dropTarget && (!shared.copy || dropTarget !== shared.source)) {\n          // found valid target and (is not copy case or target is not initial container)\n          drop(shared.item, dropTarget);\n        } else if (o.removeOnSpill) {\n          remove();\n        } else {\n          cancel(null, e);\n        }\n\n        // after release there is no container hovered\n        shared.target = null;\n\n        if (shared.lastElementBehindCursor) {\n          fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents['dragularrelease'], elementBehindCursor);\n        }\n\n        if (o.scope) {\n          o.scope.$emit('dragularrelease', shared.item, shared.source);\n        }\n      }\n\n      function drop(item, target) {\n        function emitDropEvent() {\n          if (o.scope) {\n            if (isInitialPlacement(target)) {\n              o.scope.$emit('dragularcancel', item, shared.source, shared.sourceModel, shared.initialIndex);\n            } else {\n              o.scope.$emit('dragulardrop', item, target, shared.source, shared.sourceModel, shared.initialIndex, shared.targetModel);\n            }\n          }\n        }\n        if (shared.sourceModel && !isInitialPlacement(target)) {\n          var dropElm = item,\n            dropIndex = domIndexOf(dropElm, target);\n          $rootScope.$applyAsync(function applyDrop() {\n            if (target === shared.source) {\n              shared.sourceModel.splice(dropIndex, 0, shared.sourceModel.splice(shared.initialIndex, 1)[0]);\n            } else {\n              shared.dropElmModel = shared.copy ? angular.copy(shared.sourceModel[shared.initialIndex]) : shared.sourceModel[shared.initialIndex];\n\n              if (!shared.isContainerModel) {\n                shared.targetModel = shared.targetCtx.m;\n              } else {\n                shared.targetModel = shared.isContainerModel;\n              }\n\n              target.removeChild(dropElm); // element must be removed for ngRepeat to apply correctly\n\n              if (!shared.copy) {\n                shared.sourceModel.splice(shared.initialIndex, 1);\n              }\n              shared.targetModel.splice(dropIndex, 0, shared.dropElmModel);\n            }\n\n            if (item.parentElement) {\n              item.parentElement.removeChild(item);\n            }\n\n            emitDropEvent();\n            cleanup();\n          });\n        } else {\n          emitDropEvent();\n          cleanup();\n        }\n      }\n\n      function remove() {\n        if (!drake.dragging) {\n          return;\n        }\n        var parent = shared.item.parentElement;\n\n        if (parent) {\n          parent.removeChild(shared.item);\n        }\n\n        if (shared.sourceModel) {\n          $rootScope.$applyAsync(function removeModel() {\n            shared.sourceModel.splice(shared.initialIndex, 1);\n            cleanup();\n          });\n        }\n\n        if (o.scope) {\n          o.scope.$emit(shared.copy ? 'dragularcancel' : 'dragularremove', shared.item, parent, shared.sourceModel, shared.initialIndex);\n        }\n        if (!shared.sourceModel) {\n          cleanup();\n        }\n      }\n\n      function cancel(revert, event) {\n        if (!drake.dragging) {\n          return;\n        }\n        var reverts = arguments.length > 0 ? revert : o.revertOnSpill;\n        var parent = shared.item ? shared.item.parentElement : null;\n\n        var initial = isInitialPlacement(parent);\n        if (initial === false && shared.copy === false && reverts) {\n          shared.source.insertBefore(shared.item, shared.initialSibling);\n        }\n        if (shared.sourceModel && !shared.copy && !reverts) {\n          drop(shared.item, parent);\n        } else if (o.scope) {\n          if (initial || reverts) {\n            o.scope.$emit('dragularcancel', shared.item, shared.source);\n          }\n\n          // Accomodation for touch which falls into this block\n          if (event) {\n            if (event.type === 'touchend') {\n              o.scope.$emit('dragulartouchend', shared.item, shared.source);\n            }\n          }\n        }\n\n        if (!shared.sourceModel || shared.copy || reverts || initial) {\n          cleanup();\n        }\n      }\n\n      function cleanup() {\n        ungrab();\n        removeMirrorImage();\n\n        if (shared.item) {\n          rmClass(shared.item, o.classes.transit);\n        }\n\n        drake.dragging = false;\n\n        if (o.removeOnSpill === true) {\n          spillOut();\n        }\n\n        if (o.scope) {\n          o.scope.$emit('dragularout', shared.item, shared.lastDropTarget, shared.source);\n          o.scope.$emit('dragulardragend', shared.item);\n        }\n\n        shared.source = shared.item = shared.sourceItem = shared.initialSibling = shared.currentSibling = shared.sourceModel = null;\n        shared.initialIndex = shared.currentIndex = shared.lastDropTarget = shared.isContainerModel = shared.targetModel = null;\n        shared.dropElmModel = shared.targetCtx = shared.copy = null;\n      }\n\n      // is item currently placed in original container and original position?\n      function isInitialPlacement(target, s) {\n        var sibling = s || (shared.mirror ? shared.currentSibling : nextEl(shared.item));\n        return target === shared.source && sibling === shared.initialSibling;\n      }\n\n      // find valid drop container\n      function findDropTarget(elementBehindCursor, clientX, clientY) {\n        var target = elementBehindCursor;\n\n        while (target && !accepted()) {\n          target = target.parentElement;\n        }\n        return target;\n\n        function accepted() {\n          var accepts = false;\n\n          if (isContainer(target)) { // is droppable?\n\n            var immediate = getImmediateChild(target, elementBehindCursor),\n              reference = getReference(target, immediate, clientX, clientY),\n              initial = isInitialPlacement(target, reference),\n              i = o.nameSpace.length;\n\n            while (i--) {\n              if (shared.containers[o.nameSpace[i]].indexOf(target) !== -1) {\n                shared.targetCtx = shared.containersCtx[o.nameSpace[i]][shared.containers[o.nameSpace[i]].indexOf(target)];\n                break;\n              }\n              if (!shared.targetCtx) {\n                shared.targetCtx = shared.containersCtx['dragularCommon'][shared.containers['dragularCommon'].indexOf(target)];\n              }\n            }\n\n            accepts = initial ||\n              (shared.targetCtx.o.accepts(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex) &&\n                o.canBeAccepted(shared.item, target, shared.source, reference, shared.sourceModel, shared.initialIndex));\n\n            if (shared.target !== target) { // used for scroll issue\n              shared.target = target;\n            }\n          }\n          return accepts;\n        }\n      }\n\n      function drag(e) {\n        if (!shared.mirror) {\n          return;\n        }\n        e = e || window.event;\n\n        // update coordinates\n        shared.clientX = getCoord('clientX', e);\n        shared.clientY = getCoord('clientY', e);\n\n        // count mirror coordiates\n        var x = shared.clientX - shared.offsetX,\n          y = shared.clientY - shared.offsetY,\n          pageX,\n          pageY,\n          offsetBox;\n\n        // fill extra properties if boundingBox is used\n        if (o.boundingBox) {\n          pageX = getCoord('pageX', e);\n          pageY = getCoord('pageY', e);\n          offsetBox = getOffset(o.boundingBox);\n        }\n\n        if (!o.lockY) {\n          if (!o.boundingBox || (pageX > offsetBox.left + shared.offsetX && pageX < offsetBox.right + shared.offsetXr)) {\n            shared.mirror.style.left = x + 'px';\n          } else if (o.boundingBox) { // check again in case user scrolled the view\n            if (pageX < offsetBox.left + shared.offsetX) {\n              shared.mirror.style.left = shared.clientX - (pageX - offsetBox.left) + 'px';\n            } else {\n              shared.mirror.style.left = shared.clientX - shared.mirrorWidth - (pageX - offsetBox.right) + 'px';\n            }\n          }\n        }\n        if (!o.lockX) {\n          if (!o.boundingBox || (pageY > offsetBox.top + shared.offsetY && pageY < offsetBox.bottom + shared.offsetYb)) {\n            shared.mirror.style.top = y + 'px';\n          } else if (o.boundingBox) { // check again in case user scrolled the view\n            if (pageY < offsetBox.top + shared.offsetY) {\n              shared.mirror.style.top = shared.clientY - (pageY - offsetBox.top) + 'px';\n            } else {\n              shared.mirror.style.top = shared.clientY - shared.mirrorHeight - (pageY - offsetBox.bottom) + 'px';\n            }\n          }\n        }\n\n        var elementBehindCursor = getElementBehindPoint(shared.mirror, shared.clientX, shared.clientY),\n          dropTarget = findDropTarget(elementBehindCursor, shared.clientX, shared.clientY),\n          changed = dropTarget !== shared.lastDropTarget;\n\n        if (elementBehindCursor !== shared.lastElementBehindCursor) {\n          fireEvent(elementBehindCursor, shared.dragOverEvents['dragularenter'], !!dropTarget);\n          if (shared.lastElementBehindCursor) {\n            fireEvent(shared.lastElementBehindCursor, shared.dragOverEvents['dragularleave'], elementBehindCursor);\n          }\n          shared.lastElementBehindCursor = elementBehindCursor;\n        }\n\n        if (changed) {\n          out();\n          shared.lastDropTarget = dropTarget;\n          over();\n        }\n\n        // do not copy in same container\n        if (dropTarget === shared.source && shared.copy) {\n          if (shared.item.parentElement) {\n            shared.item.parentElement.removeChild(shared.item);\n          }\n          return;\n        }\n\n        var reference,\n          immediate = getImmediateChild(dropTarget, elementBehindCursor);\n\n        if (immediate !== null) {\n          reference = getReference(dropTarget, immediate, shared.clientX, shared.clientY);\n        } else if (o.revertOnSpill === true && !shared.copy) {\n          // the case that mirror is not over valid target and reverting is on and copy is off\n          reference = shared.initialSibling;\n          dropTarget = shared.source;\n        } else {\n          // the case that mirror is not over valid target and removing is on or copy is on\n          if (shared.copy && shared.item.parentElement !== null) {\n            // remove item or copy of item\n            shared.item.parentElement.removeChild(shared.item);\n          }\n          return;\n        }\n        if (reference === null ||\n          reference !== shared.item &&\n          reference !== nextEl(shared.item) &&\n          reference !== shared.currentSibling) {\n          // moving item/copy to new container from previous one\n          shared.currentSibling = reference;\n\n          // IE11 acccomodation\n          if (dropTarget) {\n            dropTarget.insertBefore(shared.item, reference); // if reference is null item is inserted at the end\n          }\n\n          if (o.scope) {\n            o.scope.$emit('dragularshadow', shared.item, dropTarget);\n          }\n        }\n\n        function moved(type) {\n          if (o.scope) {\n            o.scope.$emit('dragular' + type, shared.item, shared.lastDropTarget, shared.source);\n          }\n          if (o.removeOnSpill === true) {\n            type === 'over' ? spillOver() : spillOut();\n          }\n        }\n\n        function over() {\n          if (changed) {\n            moved('over');\n          }\n        }\n\n        function out() {\n          if (shared.lastDropTarget) {\n            moved('out');\n          }\n        }\n      }\n\n      function spillOver() {\n        rmClass(shared.item, o.classes.hide);\n      }\n\n      function spillOut() {\n        if (drake.dragging) {\n          addClass(shared.item, o.classes.hide);\n        }\n      }\n\n      function scrollContainer(e) {\n        if (shared.target) {\n          var before = shared.target.scrollTop;\n          shared.target.scrollTop += e.deltaY;\n          // block scroll of the document when container can be scrolled\n          if (before !== shared.target.scrollTop) {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n        }\n      }\n\n      function renderMirrorImage() {\n        if (shared.mirror) {\n          return;\n        }\n        var rect = shared.sourceItem.getBoundingClientRect();\n        shared.mirror = shared.sourceItem.cloneNode(true);\n        shared.mirrorWidth = rect.width;\n        shared.mirrorHeight = rect.height;\n        shared.mirror.style.width = getRectWidth(rect) + 'px';\n        shared.mirror.style.height = getRectHeight(rect) + 'px';\n        rmClass(shared.mirror, o.classes.transit);\n        addClass(shared.mirror, o.classes.mirror);\n        o.mirrorContainer.appendChild(shared.mirror);\n        regEvent(documentElement, 'on', 'mousemove', drag);\n        addClass(body, o.classes.unselectable);\n        regEvent(shared.mirror, 'on', 'wheel', scrollContainer);\n        if (o.scope) {\n          o.scope.$emit('dragularcloned', shared.mirror, shared.sourceItem);\n        }\n      }\n\n      function removeMirrorImage() {\n        if (shared.mirror) {\n          rmClass(body, o.classes.unselectable);\n          regEvent(documentElement, 'off', 'mousemove', drag);\n          regEvent(shared.mirror, 'off', 'wheel', scrollContainer);\n          shared.mirror.parentElement.removeChild(shared.mirror);\n          shared.mirror = null;\n        }\n      }\n\n      function getImmediateChild(dropTarget, target) {\n        var immediate = target;\n        while (immediate !== dropTarget && immediate.parentElement !== dropTarget) {\n          immediate = immediate.parentElement;\n        }\n        if (immediate === documentElement) {\n          return null;\n        }\n        return immediate;\n      }\n\n      function getReference(dropTarget, target, x, y) {\n        var horizontal = o.direction === 'horizontal',\n          reference = target !== dropTarget ? inside() : outside();\n        return reference;\n\n        function outside() { // slower, but able to figure out any position\n          var len = dropTarget.children.length,\n            i, el, rect;\n          for (i = 0; i < len; i++) {\n            el = dropTarget.children[i];\n            rect = el.getBoundingClientRect();\n            if (horizontal && rect.left > x) {\n              return el;\n            }\n            if (!horizontal && rect.top > y) {\n              return el;\n            }\n          }\n          return null;\n        }\n\n        function inside() { // faster, but only available if dropped inside a child element\n          var rect = target.getBoundingClientRect();\n          if (horizontal) {\n            return resolve(x > rect.left + getRectWidth(rect) / 2);\n          }\n          return resolve(y > rect.top + getRectHeight(rect) / 2);\n        }\n\n        function resolve(after) {\n          return after ? nextEl(target) : target;\n        }\n      }\n\n      function isCopy(item, container) {\n        return typeof o.copy === 'boolean' ? o.copy : o.copy(item, container);\n      }\n\n      function getScroll(scrollProp, offsetProp) {\n        if (typeof window[offsetProp] !== 'undefined') {\n          return window[offsetProp];\n        }\n        if (documentElement.clientHeight) {\n          return documentElement[scrollProp];\n        }\n        return body[scrollProp];\n      }\n\n      function getOffset(el) {\n        var rect = el.getBoundingClientRect(),\n          scrollTop = getScroll('scrollTop', 'pageYOffset'),\n          scrollLeft = getScroll('scrollLeft', 'pageXOffset');\n        return {\n          left: rect.left + scrollLeft,\n          right: rect.right + scrollLeft,\n          top: rect.top + scrollTop,\n          bottom: rect.bottom + scrollTop\n        };\n      }\n\n      function getElementBehindPoint(point, x, y) {\n        var p = point || {},\n          state = p.className,\n          el;\n        p.className += ' ' + o.classes.hide;\n        el = document.elementFromPoint(x, y);\n        p.className = state;\n        return el;\n      }\n    };\n\n  // clean common/shared objects\n  serviceFn.cleanEnviroment = function cleanEnviroment() {\n    shared.classesCache = {};\n    shared.containersCtx = {};\n    shared.containers = {};\n    shared.mirror = undefined;\n  };\n\n  serviceFn.shared = shared;\n\n  return serviceFn;\n\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n  /****************************************************************************************************************************/\n\n  // HELPERS FUNCTIONS:\n\n  function regEvent(el, op, type, fn) {\n    var touch = {\n        mouseup: 'touchend',\n        mousedown: 'touchstart',\n        mousemove: 'touchmove'\n      },\n      $el = angular.element(el);\n\n    if (touch[type]) {\n      $el[op](touch[type], fn);\n    }\n    $el[op](type, fn);\n  }\n\n  function never() {\n    return false;\n  }\n\n  function always() {\n    return true;\n  }\n\n  function getRectWidth(rect) {\n    return rect.width || (rect.right - rect.left);\n  }\n\n  function getRectHeight(rect) {\n    return rect.height || (rect.bottom - rect.top);\n  }\n\n  function emptyObj() {\n    return {};\n  }\n\n  function nextEl(el) {\n    function manually() {\n      var sibling = el;\n      do {\n        sibling = sibling.nextSibling;\n      } while (sibling && sibling.nodeType !== 1);\n      return sibling;\n    }\n\n    if (el) {\n      return el.nextElementSibling || manually();\n    } else {\n      return el;\n    }\n  }\n\n  //Cannot use angular.isElement because we need to check plain dom element, no jQlite wrapped\n  function isElement(o) {\n    return (\n      typeof HTMLElement === 'object' ? o instanceof HTMLElement : //DOM2\n      o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n  }\n\n  function lookupClass(className) {\n    var cached = shared.classesCache[className];\n    if (cached) {\n      cached.lastIndex = 0;\n    } else {\n      shared.classesCache[className] = cached = new RegExp('(?:^|\\\\s)' + className + '(?:\\\\s|$)', 'g');\n    }\n    return cached;\n  }\n\n  function addClass(el, className) {\n    var current = el.className;\n    if (!current.length) {\n      el.className = className;\n    } else if (!lookupClass(className).test(current)) {\n      el.className += ' ' + className;\n    }\n  }\n\n  function rmClass(el, className) {\n    el.className = el.className.replace(lookupClass(className), ' ').trim();\n  }\n\n  function getEventHost(e) {\n    // on touchend event, we have to use `e.changedTouches`\n    // see http://stackoverflow.com/questions/7192563/touchend-event-properties\n    // see https://github.com/bevacqua/dragula/issues/34\n    if (e.targetTouches && e.targetTouches.length) {\n      return e.targetTouches[0];\n    }\n    if (e.changedTouches && e.changedTouches.length) {\n      return e.changedTouches[0];\n    }\n    return e;\n  }\n\n  function getCoord(coord, e) {\n    var host = getEventHost(e);\n    var missMap = {\n      pageX: 'clientX', // IE8\n      pageY: 'clientY' // IE8\n    };\n    if (coord in missMap && !(coord in host) && missMap[coord] in host) {\n      coord = missMap[coord];\n    }\n\n    // Adding support for touch events, as they are not functional in the original\n    if (host.type.indexOf('touch') < 0) {\n      return host[coord];\n    } else {\n      if (host.type.indexOf('end') > -1) {\n        // Nothing should happen for touchend\n        return;\n      } else {\n        // No clientX or clientY in a touch event\n        return host.originalEvent.touches[0][coord.replace('client', 'page')];\n      }\n    }\n  }\n\n  function domIndexOf(child, parent) {\n    return Array.prototype.indexOf.call(angular.element(parent).children(), child);\n  }\n\n  function fireEvent(target, e, extra) {\n    if (!target) {\n      return;\n    }\n    shared.extra = extra;\n    if (target.dispatchEvent) {\n      target.dispatchEvent(e);\n    } else {\n      target.fireEvent('on' + e.eventType, e);\n    }\n  }\n\n}]);\n\n},{\"./dragularModule\":2}]},{},[2]);\n"]}